// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "NoiseUtils.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct ColorInterval
{
    float start;
    float end;
    float4 colorStart;
    float4 colorEnd;
};

RWTexture2D<float4> Result;
RWStructuredBuffer<ColorInterval> ColorIntervals;

uint width;
uint height;
float scale;
float offsetX;
float offsetY;
uint octaves;
float persistence;
float lacunarity;
uint numColors;
uint type;

float GetNoise(float2 input)
{
    switch (type)
    {
        case 0:
            return Unity_GradientNoise_float(input);
        case 1:
            return abs(ClassicNoise(input) + 0.2);
        default:
            return Unity_GradientNoise_float(input);
    }
}


float FBM(float x, float y)
{
    float total = 0;
    float frequency = 1;
    float amplitude = 1;
    float maxValue = 0;

    for (uint i = 0; i < octaves; i++)
    {
        total += GetNoise(float2(x * frequency, y * frequency)) * amplitude;

        maxValue += amplitude;

        amplitude *= persistence;
        frequency *= lacunarity;
    }

    return total / maxValue;
}


float4 GetColorFromValue(float value)
{
    for (uint i = 0; i < numColors; i++)
    {
        if (value >= ColorIntervals[i].start && value <= ColorIntervals[i].end)
        {
            return lerp(ColorIntervals[i].colorStart, ColorIntervals[i].colorEnd, 
            (value - ColorIntervals[i].start) / (ColorIntervals[i].end - ColorIntervals[i].start));
        }
    }
    
    return float4(0, 0, 0, 1);
}


[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{

    float xCoord = (((float) id.x - width / 2) / (float) width) * scale + offsetX;
    float yCoord = (((float) id.y - height / 2) / (float) height) * scale + offsetY;

    float sample = FBM(xCoord, yCoord);
    
    Result[id.xy] = GetColorFromValue(sample);

}